<?php

namespace Session00Tests;

use PHPUnit\Framework\TestCase;
use Session00\Calculator;

/**
 * Tests pour la Session 0 : Initiation aux Tests Unitaires
 * 
 * üéØ OBJECTIF : Apprendre √† √©crire des tests unitaires avec PHPUnit
 * 
 * üìã PROC√âDURE :
 * 1. Analyser le code de la classe Calculator
 * 2. Identifier tous les sc√©narios √† tester
 * 3. √âcrire des tests complets pour chaque m√©thode
 * 4. Utiliser la structure AAA (Arrange, Act, Assert)
 * 5. Tester les cas limites et les exceptions
 * 
 * üí° CONSEILS :
 * - Commencez par les cas simples
 * - Testez les cas limites (z√©ro, n√©gatifs, valeurs extr√™mes)
 * - Testez les exceptions avec expectException()
 * - Nommez vos tests de mani√®re descriptive
 * - Utilisez setUp() pour initialiser les objets
 */
class CalculatorTest extends TestCase
{
    private Calculator $calculator;
    
    /**
     * M√©thode ex√©cut√©e avant chaque test
     * Permet d'initialiser un objet Calculator propre pour chaque test
     */
    protected function setUp(): void
    {
        $this->calculator = new Calculator();
    }
    
    // ========================================
    // TESTS DE LA M√âTHODE add()
    // ========================================
    
    /**
     * Test de l'addition avec des nombres positifs
     */
    public function testAddWithPositiveNumbers(): void
    {
        // Arrange (Pr√©parer)
        $a = 5.0;
        $b = 3.0;
        $expected = 8.0;
        
        // Act (Agir)
        $result = $this->calculator->add($a, $b);
        
        // Assert (V√©rifier)
        $this->assertEquals($expected, $result);
    }
    
    /**
     * Test de l'addition avec des nombres n√©gatifs
     */
    public function testAddWithNegativeNumbers(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $a = -5.0, $b = -3.0, $expected = -8.0
        // Act: Appeler $this->calculator->add($a, $b)
        // Assert: V√©rifier que le r√©sultat est √©gal √† $expected
    }
    
    /**
     * Test de l'addition avec des nombres d√©cimaux
     */
    public function testAddWithDecimalNumbers(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $a = 2.5, $b = 1.3, $expected = 3.8
        // Act: Appeler $this->calculator->add($a, $b)
        // Assert: V√©rifier que le r√©sultat est √©gal √† $expected
    }
    
    /**
     * Test de l'addition avec z√©ro
     */
    public function testAddWithZero(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $a = 5.0, $b = 0.0, $expected = 5.0
        // Act: Appeler $this->calculator->add($a, $b)
        // Assert: V√©rifier que le r√©sultat est √©gal √† $expected
    }
    
    // ========================================
    // TESTS DE LA M√âTHODE divide()
    // ========================================
    
    /**
     * Test de la division avec des nombres valides
     */
    public function testDivideWithValidNumbers(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $a = 10.0, $b = 2.0, $expected = 5.0
        // Act: Appeler $this->calculator->divide($a, $b)
        // Assert: V√©rifier que le r√©sultat est √©gal √† $expected
    }
    
    /**
     * Test de la division par z√©ro (doit lever une exception)
     */
    public function testDivideByZeroThrowsException(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $a = 10.0, $b = 0.0
        // Act & Assert: Utiliser expectException() pour v√©rifier que DivisionByZeroError est lev√©e
        // $this->expectException(DivisionByZeroError::class);
        // $this->expectExceptionMessage("Division by zero is not allowed");
        // $this->calculator->divide($a, $b);
    }
    
    /**
     * Test de la division avec des nombres d√©cimaux
     */
    public function testDivideWithDecimalNumbers(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $a = 7.5, $b = 2.5, $expected = 3.0
        // Act: Appeler $this->calculator->divide($a, $b)
        // Assert: V√©rifier que le r√©sultat est √©gal √† $expected
    }
    
    // ========================================
    // TESTS DE LA M√âTHODE calculateDiscount()
    // ========================================
    
    /**
     * Test du calcul de remise avec des valeurs valides
     */
    public function testCalculateDiscountWithValidValues(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $price = 100.0, $discountPercent = 20.0, $expected = 80.0
        // Act: Appeler $this->calculator->calculateDiscount($price, $discountPercent)
        // Assert: V√©rifier que le r√©sultat est √©gal √† $expected
    }
    
    /**
     * Test du calcul de remise avec un prix n√©gatif (doit lever une exception)
     */
    public function testCalculateDiscountWithNegativePriceThrowsException(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $price = -100.0, $discountPercent = 20.0
        // Act & Assert: Utiliser expectException() pour v√©rifier que InvalidArgumentException est lev√©e
        // $this->expectException(InvalidArgumentException::class);
        // $this->expectExceptionMessage("Price cannot be negative");
        // $this->calculator->calculateDiscount($price, $discountPercent);
    }
    
    /**
     * Test du calcul de remise avec une remise n√©gative (doit lever une exception)
     */
    public function testCalculateDiscountWithNegativeDiscountThrowsException(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $price = 100.0, $discountPercent = -10.0
        // Act & Assert: Utiliser expectException() pour v√©rifier que InvalidArgumentException est lev√©e
        // $this->expectException(InvalidArgumentException::class);
        // $this->expectExceptionMessage("Discount must be between 0 and 100");
        // $this->calculator->calculateDiscount($price, $discountPercent);
    }
    
    /**
     * Test du calcul de remise avec une remise sup√©rieure √† 100% (doit lever une exception)
     */
    public function testCalculateDiscountWithDiscountOver100ThrowsException(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $price = 100.0, $discountPercent = 150.0
        // Act & Assert: Utiliser expectException() pour v√©rifier que InvalidArgumentException est lev√©e
        // $this->expectException(InvalidArgumentException::class);
        // $this->expectExceptionMessage("Discount must be between 0 and 100");
        // $this->calculator->calculateDiscount($price, $discountPercent);
    }
    
    /**
     * Test du calcul de remise avec une remise de 0%
     */
    public function testCalculateDiscountWithZeroDiscount(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $price = 100.0, $discountPercent = 0.0, $expected = 100.0
        // Act: Appeler $this->calculator->calculateDiscount($price, $discountPercent)
        // Assert: V√©rifier que le r√©sultat est √©gal √† $expected
    }
    
    /**
     * Test du calcul de remise avec une remise de 100%
     */
    public function testCalculateDiscountWithFullDiscount(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $price = 100.0, $discountPercent = 100.0, $expected = 0.0
        // Act: Appeler $this->calculator->calculateDiscount($price, $discountPercent)
        // Assert: V√©rifier que le r√©sultat est √©gal √† $expected
    }
    
    // ========================================
    // TESTS BONUS - M√âTHODES SUPPL√âMENTAIRES
    // ========================================
    
    /**
     * Test du calcul de moyenne avec des nombres valides
     */
    public function testCalculateAverageWithValidNumbers(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $numbers = [1, 2, 3, 4, 5], $expected = 3.0
        // Act: Appeler $this->calculator->calculateAverage($numbers)
        // Assert: V√©rifier que le r√©sultat est √©gal √† $expected
    }
    
    /**
     * Test du calcul de moyenne avec un tableau vide (doit lever une exception)
     */
    public function testCalculateAverageWithEmptyArrayThrowsException(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $numbers = []
        // Act & Assert: Utiliser expectException() pour v√©rifier que InvalidArgumentException est lev√©e
        // $this->expectException(InvalidArgumentException::class);
        // $this->expectExceptionMessage("Cannot calculate average of empty array");
        // $this->calculator->calculateAverage($numbers);
    }
    
    /**
     * Test de la recherche du maximum
     */
    public function testFindMaxWithValidNumbers(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $numbers = [1, 5, 3, 9, 2], $expected = 9.0
        // Act: Appeler $this->calculator->findMax($numbers)
        // Assert: V√©rifier que le r√©sultat est √©gal √† $expected
    }
    
    /**
     * Test de la recherche du minimum
     */
    public function testFindMinWithValidNumbers(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $numbers = [5, 2, 8, 1, 9], $expected = 1.0
        // Act: Appeler $this->calculator->findMin($numbers)
        // Assert: V√©rifier que le r√©sultat est √©gal √† $expected
    }
    
    /**
     * Test de v√©rification si un nombre est pair
     */
    public function testIsEvenWithEvenNumber(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $number = 4
        // Act: Appeler $this->calculator->isEven($number)
        // Assert: V√©rifier que le r√©sultat est true avec assertTrue()
    }
    
    /**
     * Test de v√©rification si un nombre est impair
     */
    public function testIsEvenWithOddNumber(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $number = 5
        // Act: Appeler $this->calculator->isEven($number)
        // Assert: V√©rifier que le r√©sultat est false avec assertFalse()
    }
    
    /**
     * Test de v√©rification si un nombre est premier
     */
    public function testIsPrimeWithPrimeNumber(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $number = 7
        // Act: Appeler $this->calculator->isPrime($number)
        // Assert: V√©rifier que le r√©sultat est true avec assertTrue()
    }
    
    /**
     * Test de v√©rification si un nombre n'est pas premier
     */
    public function testIsPrimeWithNonPrimeNumber(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $number = 8
        // Act: Appeler $this->calculator->isPrime($number)
        // Assert: V√©rifier que le r√©sultat est false avec assertFalse()
    }
    
    /**
     * Test du calcul de factorielle
     */
    public function testFactorialWithValidNumber(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $number = 5, $expected = 120
        // Act: Appeler $this->calculator->factorial($number)
        // Assert: V√©rifier que le r√©sultat est √©gal √† $expected
    }
    
    /**
     * Test du calcul de factorielle avec un nombre n√©gatif (doit lever une exception)
     */
    public function testFactorialWithNegativeNumberThrowsException(): void
    {
        // TODO: √âcrire ce test
        // Arrange: $number = -5
        // Act & Assert: Utiliser expectException() pour v√©rifier que InvalidArgumentException est lev√©e
        // $this->expectException(InvalidArgumentException::class);
        // $this->expectExceptionMessage("Cannot calculate factorial of negative number");
        // $this->calculator->factorial($number);
    }
}
